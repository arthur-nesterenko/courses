---
title: Graphql
---

import Admonition from "react-admonitions";

## ER-модель (Entity-relationship model)?

<img
  src="https://i.pinimg.com/originals/d8/8e/b5/d88eb56e60fedcdbbc9bac3aa7e79394.jpg"
  alt="erm"
/>
ER-модель (Entity-relationship model или Entity-relationship diagram) - это семантическая
модель данных, которая предназначена для упрощения процесса проектирования базы данных.
С ER-модели могут быть порождены все виды баз данных:

- реляционные,
- иерархические,
- сетевые,
- объектные.

В основе ER-модели лежат понятия "сущность", "связь" и "атрибут".

ER-модель - это представление базы данных в виде наглядных графических диаграмм.
ER-модель визуализирует процесс, определяющий некоторую предметную область.
Диаграмма "сущность-связь" - это диаграмма, которая представляет в графическом виде сущности, атрибуты и связи.

<Admonition type="important">
  **ER-модель** - это только концептуальный уровень моделирования. ER-модель не
  содержит деталей реализации.
</Admonition>

## Что такое сущность в базе данных?

Суть в базе данных - это любой объект в базе данных, который можно выделить исходя из сути предметной области для которой разрабатывается эта база данных.
Разработчик базы данных должен уметь правильно определять сущности.

**Пример 1.** В базе данных книжного магазина можно выделить следующие сущности:

- книга;
- поставщик;
- размещения в магазине.

## Для чего предназначены атрибуты?

Каждый тип сущности имеет определенный набор атрибутов.
Атрибуты предназначены для описания конкретной сущности.

Различают следующие виды атрибутов:

- простые атрибуты. Это атрибуты, которые могут быть частью составленных атрибутов. Эти атрибуты состоят из одного компонента.
  Например, к простым атрибутов можно отнести код книги в библиотеке или курс обучения студента в учебном заведении;
- составлены атрибуты. Это атрибуты, которые состоят из нескольких простых атрибутов.
  Например, адрес проживания может содержать название страны, населенного пункта, улицы, номера дома;
- однозначные атрибуты. Это атрибуты, которые содержат только одно единственное значение для некоторой сущности.
  Например, атрибут "Номер зачетной книги" для типа сущности «Студент» является однозначным, потому что студент может иметь только один номер зачетной книги (одно значение)
- многозначные атрибуты. Это атрибуты, которые могут содержать несколько значений.
  Например, многозначный атрибут "Номер телефона" для сущности «Студент», потому что студент может иметь несколько номеров телефона (домашний и мобильный)
- произвольные атрибуты. Это атрибуты, значения которых формируются на основе значений других атрибутов.
  Например, текущий курс студента можно вычислить на основе разницы текущего года обучения и года вступления студента в учебное заведение (если студент не имел проблем с учебой и хорошо изучил дисциплину "Организация баз данных и знаний»).

<Admonition type="note">
  Главный плюс модели проектирования Entity Relationship — это то, что она
  универсальна. Можно проектировать Базы данных, работу какой-либо программы,
  принципы взаимодействия и др.
</Admonition>

## Типы связи

Один ко многим:

<img
  src="https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%9E%D0%B4%D0%B8%D0%BD-%D0%BA%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%B8%D0%BC.png"
  alt="one-to-many"
/>

Многое ко многим(M:N):

<img
  src="https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%9C%D0%BD%D0%BE%D0%B3%D0%B8%D0%B5-%D0%BA%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%B8%D0%BC.png"
  alt="many-to-many"
/>

## GraphQL

GraphQL — язык запросов с открытымисходным кодом, разработанный Facebook.
Он создавался как более эффективная
альтернатива REST для разработки и использования программных интерфейсов
приложений.

GraphQL обладает множеством достоинств, например:

- Вы получаете информацию именно в том объёме, в котором запрашиваете. В отличие от REST, ответ на запрос не будет содержать ненужных данных.
- Вам будет необходима всего одна конечная точка, никаких дополнительных версий для единственного API.
- GraphQL — сильно типизированный язык, что позволяет предварительно оценить корректность запроса в рамках системы типов этого синтаксиса, до исполнения. Это позволяет разрабатывать более мощные API.

В GraphQL вы столкнетесь с 3 основными концепциями:

Запросы (queries) – то, с помощью чего вы будете получать данные с сервера;
Мутации (mutations) – то, как вы будете модифицировать данные на сервере и возвращать обновленные данные (создавать, обновлять, удалять);
Подписки (subscriptions) – то, с помощью чего вы будете поддерживать связь с сервером в режиме реального времени.

## Запросы

C помощью запросов в GraphQL вы будете получать данные. В GraphQL вы получите именно необходимые вам данные, не меньше и не больше. Это положительно сказывается на API. Вы больше не будете получать слишком много или слишком мало информации, как бывало с REST API.

Первым типом в GraphQL будет Query. Последующие запросы будут оказываться в этом типе.

```typescript
type Query {
    users: [User!]!
    //...
}
```

## Мутации

В GraphQL мутации – это то, как вы собираетесь модифицировать данные, находящиеся на сервере, и получать их обратно с учетом обновлений. По сути, это CUD (Create, Update, Delete – создание, обновление, удаление) в REST.
Все мутации, созданные нами, будут оказываться в типе Mutation.

```typescript
type Mutation {
    createUser(id: ID!, name: String!, email: String!, age: Int): User!
    updateUser(id: ID!, name: String, email: String, age: Int): User!
    deleteUser(id: ID!): User!
}
```

Вы можете понять, что у нас будет всего 3 мутации.

`createUser`: мы передаем ID, age, email, name. В ответ мы получим нового пользователя.

`updateUser`: мы передаем ID и новые email, age или name. В ответ мы получим нового пользователя.

`deleteUser`: мы передаем ID. В ответ мы получим нового пользователя.

GraphQL обеспечивает любую вложенность запросов при наличии тех или иных ссылок на другие типы, как при добавлении, так и при чтении данных:

```graphql
type Category {
  _id: ID
  createdAt: String
  name: String
  goods: [Good]
  image: Image
  owner: User
  parent: Category
  subCategories: [Category]
}

input CategoryInput {
  _id: ID
  name: String!
  goods: [GoodInput]
  image: ImageInput

  parent: CategoryInput
  subCategories: [CategoryInput]
}

type Good {
  _id: ID
  createdAt: String
  name: String
  description: String
  price: Float
  orderGoods: [OrderGood]
  categories: [Category]
  images: [Image]
  owner: User
}

input GoodInput {
  _id: ID
  name: String
  description: String
  price: Float
  categories: [CategoryInput]
  images: [ImageInput]
}
```

В примере выше прописаны связи:

- goods: [Good] - каждая категория имеет массив товаров в ней;
- parent: Category каждая категория может иметь родительскую;
- subCategories: [Category] массив подкатегорий

Аналогично прописаны связи в input, что дает возможность отправлять mutation с вложенными изменениями/добавлениями
В свою очередь, в Good есть связь categories: [Category]

**Upsert**
Update-Insert - операция добавления или изменения данных. При передаче `_id` сущности происходит изменение, иначе - добавление. Тоже самое касается вложенных сущностей при любых mutation.

## Установка связи без изменения

Для этого достаточно при Upsert указать в объектах только `_id` и более никаких полей:

```graphql
mutation setAvatar {
  UserUpsert(user: { _id: "myid", avatar: { _id: "image id from fetch" } }) {
    _id
    avatar {
      _id
    }
  }
}
```

**Массивы**

Массивы перезаписываются целиком. Поэтому вначале сделайте им push или filter, а потом - Upsert

<Admonition type="note">
  Обычно связи - двунаправленные, т. е. если в категории есть массив товаров, то
  и в товарах есть массив категорий, к которым он относится. Если у юзера есть
  аватар, то и в картинке указано, что она связана с юзером.
</Admonition>

## Почитать 📚

- [GraphQL для начинающих](http://falbar.ru/article/graphql-dlya-nachinayushhix)
- [Что же такое GraphQL?](https://habr.com/ru/post/326986/)
- [Ввeдение в GraphQL](https://webdevblog.ru/vvedenie-v-graphql/)

## Практика (ДЗ)👩‍💻👨‍💻

<iframe
  src="https://codesandbox.io/embed/shop-project-ms7cy?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: "100%",
    height: "500px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden",
  }}
  title="shop-project"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>

- Создать страницу поиска `GoodFind`
- Создать страницу входа
